name: Decompile APK and Upload to Repository

on:
  workflow_dispatch:
    inputs:
      apk_url:
        description: 'URL to download the APK'
        required: true
        type: string
      target_username:
        description: 'GitHub username where the repository will be created'
        required: true
        type: string
      quiet:
        description: 'Suppress normal output (-q/--quiet)'
        required: false
        type: boolean
        default: false
      verbose:
        description: 'Increase output verbosity (-v/--verbose)'
        required: false
        type: boolean
        default: false
      force:
        description: 'Force delete destination directory (-f/--force)'
        required: false
        type: boolean
        default: false
      jobs:
        description: 'Number of jobs to execute in parallel (-j/--jobs)'
        required: false
        type: string
        default: ''
      lib:
        description: 'Use shared library package:file, comma-separated for multiple (-l/--lib)'
        required: false
        type: string
        default: ''
      keep_debug_info:
        description: 'Include debug info in sources (default: disabled with --no-debug-info)'
        required: false
        type: boolean
        default: false
      advanced_options:
        description: 'Additional apktool decode flags: -r (skip resources), -s (skip sources), --only-main-classes (main dex only), --only-manifest (manifest only), --res-resolve-mode <mode> (default/greedy/lazy), --keep-broken-res (keep broken), --match-original (match original), --no-assets (skip assets)'
        required: false
        type: string
        default: ''

jobs:
  decompile-and-upload:
    runs-on: ubuntu-22.04
    permissions:
      contents: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Setup zram for additional memory
        run: |
          echo "Setting up zram for compressed swap..."
          # Install zram-config if not available
          sudo apt-get update -qq
          # Configure zram to use 8GB of compressed RAM
          sudo apt install "linux-modules-extra-$(uname -r)" zram-tools -y
          sudo modprobe zram
          sudo sed -i 's/^#PERCENT=50/PERCENT=90/' /etc/default/zramswap
          sudo sed -i 's/^#PRIORITY=100/PRIORITY=1000/' /etc/default/zramswap
          sudo systemctl restart zramswap
          zramctl

      - name: Set up Java
        uses: actions/setup-java@v5
        with:
          distribution: 'zulu'
          java-version: '17'

      - name: Download apktool from latest release
        run: |
          echo "Downloading apktool.jar and script from latest release..."

          # Get the latest release info
          LATEST_RELEASE=$(curl -s https://api.github.com/repos/${{ github.repository }}/releases/latest)

          # Extract download URLs using jq for reliable JSON parsing
          JAR_URL=$(echo "$LATEST_RELEASE" | jq -r '.assets[] | select(.name | endswith(".jar")) | .browser_download_url' | head -1)
          SCRIPT_URL=$(echo "$LATEST_RELEASE" | jq -r '.assets[] | select(.name == "apktool") | .browser_download_url' | head -1)

          if [ -z "$JAR_URL" ] || [ -z "$SCRIPT_URL" ]; then
            echo "Error: Could not find apktool.jar or script in latest release"
            echo "JAR_URL: $JAR_URL"
            echo "SCRIPT_URL: $SCRIPT_URL"
            exit 1
          fi

          echo "Downloading apktool.jar from: $JAR_URL"
          echo "Downloading apktool script from: $SCRIPT_URL"

          # Create directory for apktool
          mkdir -p apktool-bin

          # Download files
          curl -L -o apktool-bin/apktool.jar "$JAR_URL"
          curl -L -o apktool-bin/apktool "$SCRIPT_URL"

          # Make the script executable
          chmod +x apktool-bin/apktool

          # Add to PATH
          echo "$GITHUB_WORKSPACE/apktool-bin" >> "$GITHUB_PATH"

          # Verify setup
          ls -la apktool-bin/
          echo "Apktool downloaded and configured in PATH"

      - name: Download Samsung framework
        run: |
          echo "Downloading Samsung dm2q framework..."
          curl -L -o framework-dm2q.apk "https://gitlab.com/Eduardob3677/samsung_dm2q_dump/-/raw/dm2qxxx-user-16-BP2A.250605.031.A3-S916BXXS8EYK2-release-keys/system/system/framework/framework-res.apk"
          if [ ! -f framework-dm2q.apk ]; then
            echo "Error: Failed to download framework"
            exit 1
          fi
          echo "Framework downloaded successfully"
          ls -lh framework-dm2q.apk

      - name: Install framework with dm2q tag
        run: |
          echo "Creating framework directory..."
          mkdir -p apktool-frameworks
          echo "Installing framework with tag dm2q to apktool-frameworks..."
          apktool if framework-dm2q.apk -t dm2q -p apktool-frameworks
          echo "Framework installed successfully with tag dm2q"

      - name: Download APKEditor
        run: |
          echo "Downloading APKEditor.jar from latest release..."

          # Check if jq is available, install if not
          if ! command -v jq &> /dev/null; then
            echo "jq is not installed, installing..."
            sudo apt-get update -qq && sudo apt-get install -y jq
          fi

          # Get the latest release info from REAndroid/APKEditor
          LATEST_RELEASE=$(curl -s https://api.github.com/repos/REAndroid/APKEditor/releases/latest)

          # Check if curl succeeded and returned valid JSON
          if [ -z "$LATEST_RELEASE" ] || ! echo "$LATEST_RELEASE" | jq empty 2>/dev/null; then
            echo "Error: Failed to fetch or parse release information from GitHub API"
            exit 1
          fi

          # Extract download URL for APKEditor.jar (matches APKEditor-X.Y.Z.jar or APKEditor.jar)
          JAR_URL=$(echo "$LATEST_RELEASE" | jq -r '.assets[] | select(.name | test("^APKEditor(-[0-9]+\\.[0-9]+\\.[0-9]+)?\\.jar$")) | .browser_download_url' | head -1)

          if [ -z "$JAR_URL" ] || [ "$JAR_URL" = "null" ]; then
            echo "Error: Could not find APKEditor.jar in latest release"
            echo "Available assets:"
            echo "$LATEST_RELEASE" | jq -r '.assets[].name' || echo "Failed to list assets"
            exit 1
          fi

          echo "Downloading APKEditor.jar from: $JAR_URL"

          # Download APKEditor
          curl -L -o APKEditor.jar "$JAR_URL"

          # Verify download
          if [ ! -f APKEditor.jar ]; then
            echo "Error: Failed to download APKEditor.jar"
            exit 1
          fi

          ls -lh APKEditor.jar
          echo "APKEditor downloaded successfully"

      - name: Download and convert APK
        run: |
          echo "Downloading file from ${{ github.event.inputs.apk_url }}"

          # Download the file with a temporary name
          curl -L -o downloaded_file "${{ github.event.inputs.apk_url }}"

          if [ ! -f downloaded_file ]; then
            echo "Error: Failed to download file"
            exit 1
          fi

          echo "File downloaded successfully"
          ls -lh downloaded_file

          # Extract filename from URL for extension detection
          # Note: This is only used for format detection, not for actual URL access
          URL_PATH="${{ github.event.inputs.apk_url }}"
          # Remove everything up to the last slash
          URL_FILENAME="${URL_PATH##*/}"
          # Remove query parameters and fragments
          URL_FILENAME="${URL_FILENAME%%[?#]*}"
          # Convert to lowercase for case-insensitive extension matching
          URL_FILENAME_LOWER=$(echo "$URL_FILENAME" | tr '[:upper:]' '[:lower:]')

          echo "Detected filename: $URL_FILENAME_LOWER"

          # Check file type using file command for additional validation
          FILE_TYPE=$(file -b --mime-type downloaded_file)
          echo "Detected MIME type: $FILE_TYPE"

          # Check if the file is APKM, APKS, or XAPK (these are typically zip files)
          # We check both the extension and verify it's a zip file
          case "$URL_FILENAME_LOWER" in
            *.apkm|*.apks|*.xapk)
              # Verify the file is actually a zip file
              if [[ "$FILE_TYPE" == "application/zip" ]] || [[ "$FILE_TYPE" == "application/java-archive" ]]; then
                echo "Detected split APK format (APKM/APKS/XAPK) from URL extension, converting to APK..."

                # Use APKEditor to merge the split APK files into a single APK
                echo "Running: java -jar APKEditor.jar m -i downloaded_file -o app.apk"
                if ! java -jar APKEditor.jar m -i downloaded_file -o app.apk; then
                  echo "Error: APKEditor failed to convert split APK to APK"
                  exit 1
                fi

                if [ ! -f app.apk ]; then
                  echo "Error: Failed to convert split APK to APK - output file not created"
                  exit 1
                fi

                echo "Conversion completed successfully"
                ls -lh app.apk

                # Clean up the original downloaded file
                rm -f downloaded_file
              else
                echo "Warning: File extension suggests split APK format, but MIME type is $FILE_TYPE"
                echo "Treating as regular APK"
                mv downloaded_file app.apk
              fi
              ;;
            *)
              # If it's a regular APK or unknown format, just rename it
              echo "File appears to be a regular APK (or unknown format), treating as APK"
              mv downloaded_file app.apk
              ;;
          esac

          # Verify final APK exists
          if [ ! -f app.apk ]; then
            echo "Error: app.apk not found after processing"
            exit 1
          fi

          echo "Final APK ready for decompilation"
          ls -lh app.apk

      - name: Decompile APK
        run: |
          echo "Decompiling APK with dm2q framework..."
          # Build apktool command with optional parameters using array
          # Note: --no-debug-info is controlled by keep_debug_info input
          CMD=(apktool d -o decompiled -t dm2q -p apktool-frameworks)

          # Check mutual exclusivity of quiet and verbose flags
          if [ "${{ github.event.inputs.quiet }}" = "true" ] && [ "${{ github.event.inputs.verbose }}" = "true" ]; then
            echo "Error: quiet and verbose flags are mutually exclusive"
            exit 1
          fi

          # Add optional quiet flag
          if [ "${{ github.event.inputs.quiet }}" = "true" ]; then
            CMD+=(-q)
            echo "Using quiet mode (-q)"
          fi

          # Add optional verbose flag
          if [ "${{ github.event.inputs.verbose }}" = "true" ]; then
            CMD+=(-v)
            echo "Using verbose mode (-v)"
          fi

          # Add optional force flag
          if [ "${{ github.event.inputs.force }}" = "true" ]; then
            CMD+=(-f)
            echo "Using force mode (-f)"
          fi

          # Add optional jobs parameter with validation
          if [ -n "${{ github.event.inputs.jobs }}" ]; then
            # Validate that jobs is a non-negative integer (0 means auto-detect)
            if ! [[ "${{ github.event.inputs.jobs }}" =~ ^[0-9]+$ ]]; then
              echo "Error: jobs must be a non-negative integer (0 for auto-detect)"
              exit 1
            fi
            CMD+=(-j "${{ github.event.inputs.jobs }}")
            if [ "${{ github.event.inputs.jobs }}" = "0" ]; then
              echo "Using auto-detect for parallel jobs"
            else
              echo "Using ${{ github.event.inputs.jobs }} parallel jobs"
            fi
          fi

          # Add optional lib parameter (can be multiple, comma-separated) with validation
          if [ -n "${{ github.event.inputs.lib }}" ]; then
            IFS=',' read -ra LIBS <<< "${{ github.event.inputs.lib }}"
            for lib in "${LIBS[@]}"; do
              # Trim whitespace
              lib=$(echo "$lib" | xargs)
              # Validate format: package:file and prevent path traversal
              if ! [[ "$lib" =~ ^[a-zA-Z0-9._-]+:[a-zA-Z0-9._/-]+$ ]]; then
                echo "Error: lib format must be package:file (got: $lib)"
                exit 1
              fi
              # Check for path traversal sequences
              if [[ "$lib" == *".."* ]]; then
                echo "Error: lib path cannot contain '..' sequences"
                exit 1
              fi
              CMD+=(-l "$lib")
              echo "Using shared library: $lib"
            done
          fi

          # Add no-debug-info flag (default behavior unless keep_debug_info is true)
          if [ "${{ github.event.inputs.keep_debug_info }}" != "true" ]; then
            CMD+=(--no-debug-info)
            echo "Excluding debug info from sources (--no-debug-info)"
          else
            echo "Keeping debug info in sources"
          fi

          # Add advanced options if provided
          if [ -n "${{ github.event.inputs.advanced_options }}" ]; then
            echo "Adding advanced options: ${{ github.event.inputs.advanced_options }}"
            # Note: advanced_options should only contain apktool flags
            # Allowed flags: -r, -s, --only-main-classes, --only-manifest,
            # --res-resolve-mode <mode>, --keep-broken-res, --match-original, --no-assets
            # Basic validation: ensure no dangerous characters or command injection
            if [[ "${{ github.event.inputs.advanced_options }}" =~ [';|&$`<>'] ]]; then
              echo "Error: advanced_options contains potentially dangerous characters"
              exit 1
            fi
            read -ra ADV_OPTS <<< "${{ github.event.inputs.advanced_options }}"
            CMD+=("${ADV_OPTS[@]}")
          fi

          # Add APK file at the end
          CMD+=(app.apk)

          echo "Executing: ${CMD[*]}"
          "${CMD[@]}"

          if [ ! -d decompiled ]; then
            echo "Error: Decompilation failed"
            exit 1
          fi
          echo "Decompilation completed successfully"

      - name: Extract package name
        id: package-name
        run: |
          # Extract package name from AndroidManifest.xml
          if [ -f decompiled/AndroidManifest.xml ]; then
            PACKAGE=$(grep -oP 'package="\K[^"]+' decompiled/AndroidManifest.xml | head -n 1)
            if [ -z "$PACKAGE" ]; then
              echo "Error: Could not extract package name"
              exit 1
            fi
            # Replace dots with underscores
            REPO_NAME=$(echo "$PACKAGE" | tr '.' '_')
            echo "package=$PACKAGE" >> "$GITHUB_OUTPUT"
            echo "repo_name=$REPO_NAME" >> "$GITHUB_OUTPUT"
            echo "Package: $PACKAGE"
            echo "Repository name: $REPO_NAME"
          else
            echo "Error: AndroidManifest.xml not found"
            exit 1
          fi

      - name: Check and create repository
        id: create-repo
        env:
          GH_TOKEN: ${{ secrets.TEST }}
          TARGET_USER: ${{ github.event.inputs.target_username }}
          BASE_REPO_NAME: ${{ steps.package-name.outputs.repo_name }}
        run: |
          REPO_NAME="$BASE_REPO_NAME"
          COUNTER=2

          # Check if repository exists and find available name
          while gh repo view "$TARGET_USER/$REPO_NAME" &>/dev/null; do
            echo "Repository $TARGET_USER/$REPO_NAME already exists"
            REPO_NAME="${BASE_REPO_NAME}_${COUNTER}"
            COUNTER=$((COUNTER + 1))
          done

          echo "Creating repository: $TARGET_USER/$REPO_NAME"
          gh repo create "$TARGET_USER/$REPO_NAME" --public --description "Decompiled APK: ${{ steps.package-name.outputs.package }}"

          echo "final_repo_name=$REPO_NAME" >> "$GITHUB_OUTPUT"
          echo "Repository created: $TARGET_USER/$REPO_NAME"

      - name: Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Install Git LFS
        run: |
          # Install Git LFS (should already be available on ubuntu-latest)
          git lfs version || (sudo apt-get update && sudo apt-get install -y git-lfs)
          echo "Git LFS installed successfully"

      - name: Track large files with Git LFS
        run: |
          cd decompiled

          # Initialize git repository first (needed for git lfs)
          git init

          # Initialize Git LFS
          git lfs install

          # Find files larger than 99MB and track them with Git LFS
          echo "Scanning for files larger than 99MB..."
          LARGE_FILES_FOUND=false

          # Find files larger than 99MB (99 * 1024 * 1024 bytes = 103,809,024 bytes = 99 MiB)
          # Using MiB (binary) threshold to stay safely under GitHub's 100MB limit
          while IFS= read -r -d '' file; do
            if [ -f "$file" ]; then
              size=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null)
              if [ "$size" -gt 103809024 ]; then
                LARGE_FILES_FOUND=true
                # Calculate size in MB for display (without bc dependency)
                size_mb=$((size / 1024 / 1024))
                echo "Found large file: $file (${size_mb}MB)"

                # Track this file pattern with git lfs
                git lfs track "$file"
              fi
            fi
          done < <(find . -type f -print0)

          if [ "$LARGE_FILES_FOUND" = true ]; then
            echo "✅ Large files tracked with Git LFS"
            echo "Git LFS tracking patterns:"
            cat .gitattributes
          else
            echo "ℹ️  No files larger than 99MB found"
          fi

      - name: Push decompiled content to new repository
        env:
          GH_TOKEN: ${{ secrets.TEST }}
          TARGET_USER: ${{ github.event.inputs.target_username }}
          REPO_NAME: ${{ steps.create-repo.outputs.final_repo_name }}
        run: |
          cd decompiled

          # Add all files (git lfs will handle large files automatically)
          git add .

          # Commit with information about large files if any
          if [ -f .gitattributes ]; then
            git commit -m "Initial commit: Decompiled APK (${{ steps.package-name.outputs.package }})" \
                       -m "Large files tracked with Git LFS (see .gitattributes)"
          else
            git commit -m "Initial commit: Decompiled APK (${{ steps.package-name.outputs.package }})"
          fi

          # Configure remote and push
          git remote add origin "https://x-access-token:${GH_TOKEN}@github.com/$TARGET_USER/$REPO_NAME.git"
          git branch -M main

          # Push to remote (Git LFS pre-push hook will automatically handle LFS files)
          echo "Pushing content to repository..."
          git push -u origin main

          echo "✅ Decompiled content pushed successfully to: https://github.com/$TARGET_USER/$REPO_NAME"

      - name: Summary
        run: |
          {
            echo "## Decompilation Summary"
            echo ""
            echo "- **Package**: ${{ steps.package-name.outputs.package }}"
            echo "- **Repository**: [${{ github.event.inputs.target_username }}/${{ steps.create-repo.outputs.final_repo_name }}](https://github.com/${{ github.event.inputs.target_username }}/${{ steps.create-repo.outputs.final_repo_name }})"
            echo ""
            echo "✅ Decompilation completed successfully!"
          } >> "$GITHUB_STEP_SUMMARY"
